\rSec1[optional]{Optional objects}

\rSec2[optional.general]{General}

\pnum
Subclause~\ref{optional} describes class template \tcode{optional} that represents
optional objects.
An \defn{optional object} is an
object that contains the storage for another object and manages the lifetime of
this contained object, if any. The contained object may be initialized after
the optional object has been initialized, and may be destroyed before the
optional object has been destroyed. The initialization state of the contained
object is tracked by the optional object.

\rSec2[optional.syn]{Header \tcode{<optional>} synopsis}

\indexheader{optional}%
\begin{codeblock}
// mostly freestanding
#include <compare>              // see \ref{compare.syn}

namespace std {
  // \ref{optional.optional}, class template \tcode{optional} for object types
  template <class T>
  class optional; // partially freestanding

  @\added{// \ref{optional.optionalref}, class template \tcode{optional} for reference types }@
  @\added{template <class T> }@
  @\added{class optional<T\&>; // partially freestanding}@

  template <class T>
  inline constexpr bool ranges::enable_view<optional<T>> = true;
  template <class T>
  inline constexpr auto format_kind<optional<T>> = range_format::disabled;
  @\added{template<class T>}@
  @\added{constexpr bool ranges::enable_borrowed_range<optional<T>> = is_reference_v<T>;}@

  template<class T>
    concept @\defexposconcept{is-derived-from-optional}@ = requires(const T& t) {       // \expos
      []<class U>(const optional<U>&){ }(t);
    };

  // \ref{optional.nullopt}, no-value state indicator
  struct nullopt_t{@\seebelow@};
  inline constexpr nullopt_t nullopt(@\unspec@);

  // \ref{optional.bad.access}, class \tcode{bad_optional_access}
  class bad_optional_access;

  // \ref{optional.relops}, relational operators
  template<class T, class U>
    constexpr bool operator==(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator!=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>=(const optional<T>&, const optional<U>&);
  template<class T, @\libconcept{three_way_comparable_with}@<T> U>
    constexpr compare_three_way_result_t<T, U>
      operator<=>(const optional<T>&, const optional<U>&);

  // \ref{optional.nullops}, comparison with \tcode{nullopt}
  template<class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
  template<class T>
    constexpr strong_ordering operator<=>(const optional<T>&, nullopt_t) noexcept;

  // \ref{optional.comp.with.t}, comparison with \tcode{T}
  template<class T, class U> constexpr bool operator==(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator==(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator!=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator!=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>=(const T&, const optional<U>&);
  template<class T, class U>
      requires (!@\exposconcept{is-derived-from-optional}@<U>) && @\libconcept{three_way_comparable_with}@<T, U>
    constexpr compare_three_way_result_t<T, U>
      operator<=>(const optional<T>&, const U&);

  // \ref{optional.specalg}, specialized algorithms
  template<class T>
    constexpr void swap(optional<T>&, optional<T>&) noexcept(@\seebelow@);

  template<class T>
    constexpr optional<@\seebelow@> make_optional(T&&);
  template<class T, class... Args>
    constexpr optional<T> make_optional(Args&&... args);
  template<class T, class U, class... Args>
    constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);

  // \ref{optional.hash}, hash support
  template<class T> struct hash;
  template<class T> struct hash<optional<T>>;
}
\end{codeblock}

\rSec2[optional.optional]{Class template \tcode{optional} \added{for object types}}

\rSec3[optional.optional.general]{General}

\indexlibraryglobal{optional}%
\indexlibrarymember{value_type}{optional}%
\begin{codeblock}
namespace std {
  template<class T>
  class optional {
  public:
    using value_type     = T;
    using iterator       = @\impdefnc@;              // see~\ref{optional.iterators}
    using const_iterator = @\impdefnc@;              // see~\ref{optional.iterators}

    // \ref{optional.ctor}, constructors
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional&);
    constexpr optional(optional&&) noexcept(@\seebelow@);

    template<class... Args>
      constexpr explicit optional(in_place_t, Args&&...);
    template<class U, class... Args>
      constexpr explicit optional(in_place_t, initializer_list<U>, Args&&...);
    template<class U = T>
      constexpr explicit(@\seebelow@) optional(U&&);
    template<class U>
      constexpr explicit(@\seebelow@) optional(const optional<U>&);
    template<class U>
      constexpr explicit(@\seebelow@) optional(optional<U>&&);

    // \ref{optional.dtor}, destructor
    constexpr ~optional();

    // \ref{optional.assign}, assignment
    constexpr optional& operator=(nullopt_t) noexcept;
    constexpr optional& operator=(const optional&);
    constexpr optional& operator=(optional&&) noexcept(@\seebelow@);
    template<class U = T> constexpr optional& operator=(U&&);
    template<class U> constexpr optional& operator=(const optional<U>&);
    template<class U> constexpr optional& operator=(optional<U>&&);
    template<class... Args> constexpr T& emplace(Args&&...);
    template<class U, class... Args> constexpr T& emplace(initializer_list<U>, Args&&...);

    // \ref{optional.swap}, swap
    constexpr void swap(optional&) noexcept(@\seebelow@);

    // \ref{optional.iterators}, iterator support
    constexpr iterator begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator end() noexcept;
    constexpr const_iterator end() const noexcept;

    // \ref{optional.observe}, observers
    constexpr const T* operator->() const noexcept;
    constexpr T* operator->() noexcept;
    constexpr const T& operator*() const & noexcept;
    constexpr T& operator*() & noexcept;
    constexpr T&& operator*() && noexcept;
    constexpr const T&& operator*() const && noexcept;
    constexpr explicit operator bool() const noexcept;
    constexpr bool has_value() const noexcept;
    constexpr const T& value() const &;                                 // freestanding-deleted
    constexpr T& value() &;                                             // freestanding-deleted
    constexpr T&& value() &&;                                           // freestanding-deleted
    constexpr const T&& value() const &&;                               // freestanding-deleted
    template<class U> constexpr T value_or(U&&) const &;
    template<class U> constexpr T value_or(U&&) &&;

    // \ref{optional.monadic}, monadic operations
    template<class F> constexpr auto and_then(F&& f) &;
    template<class F> constexpr auto and_then(F&& f) &&;
    template<class F> constexpr auto and_then(F&& f) const &;
    template<class F> constexpr auto and_then(F&& f) const &&;
    template<class F> constexpr auto transform(F&& f) &;
    template<class F> constexpr auto transform(F&& f) &&;
    template<class F> constexpr auto transform(F&& f) const &;
    template<class F> constexpr auto transform(F&& f) const &&;
    template<class F> constexpr optional or_else(F&& f) &&;
    template<class F> constexpr optional or_else(F&& f) const &;

    // \ref{optional.mod}, modifiers
    constexpr void reset() noexcept;

  private:
    T *val;         // \expos
  };

  template<class T>
    optional(T) -> optional<T>;
}
\end{codeblock}

\pnum
Any instance of \tcode{optional<T>} at any given time either contains a value or does not contain a value.
When an instance of \tcode{optional<T>} \defnx{contains a value}{contains a value!\idxcode{optional}},
it means that an object of type \tcode{T}, referred to as the optional object's \defnx{contained value}{contained value!\idxcode{optional}},
is allocated within the storage of the optional object.
Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.
When an object of type \tcode{optional<T>} is contextually converted to \tcode{bool},
the conversion returns \tcode{true} if the object contains a value;
otherwise the conversion returns \tcode{false}.

\pnum
When an \tcode{optional<T>} object contains a value,
member \tcode{val} points to the contained value.

\begin{removedblock}
\tcode{T} shall be a  type
other than \cv{} \tcode{in_place_t} or \cv{} \tcode{nullopt_t}
that meets the \oldconcept{Destructible} requirements (cpp17.destructible).
\end{removedblock}

\begin{addedblock}
\pnum
A type \tcode{X} is a valid value type for \tcode{optional} if \tcode{remove_cv_t<X>} is an lvalue reference type,
or a complete non-array object type, and \tcode{remove_cvref_t<X>} is a type other than \cv{} \tcode{in_place_t} or \cv{} \tcode{nullopt_t}.

\pnum
\tcode{T} shall be an object type that is valid value type for \tcode{optional} and meets the \oldconcept{Destructible} requirements (cpp17.destructible).
\end{addedblock}

\rSec3[optional.ctor]{Constructors}


\rSec3[optional.dtor]{Destructor}

\rSec3[optional.assign]{Assignment}


\rSec3[optional.swap]{Swap}

\rSec3[optional.iterators]{Iterator support}

\rSec3[optional.observe]{Observers}

\rSec3[optional.monadic]{Monadic operations}

\indexlibrarymember{and_then}{optional}
\begin{itemdecl}
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{invoke_result_t<F, decltype(*\exposid{val})>}.

\pnum
\mandates
\tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return invoke(std::forward<F>(f), *@\exposid{val}@);
} else {
  return remove_cvref_t<U>();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{and_then}{optional}
\begin{itemdecl}
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{invoke_result_t<F, decltype(std::move(*\exposid{val}))>}.

\pnum
\mandates
\tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return invoke(std::forward<F>(f), std::move(*\exposid{val}));
} else {
  return remove_cvref_t<U>();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{transform}{optional}
\begin{itemdecl}
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, decltype(*\exposid{val})>>}.

\pnum
\mandates
\begin{removedblock}
\tcode{U} is a non-array object type
other than \tcode{in_place_t} or \tcode{nullopt_t}.
\end{removedblock}
\begin{addedblock}
\tcode{U} is valid type for optional.
\end{addedblock}
The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), *@\exposid{val}@));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

\pnum
\returns
If \tcode{*this} contains a value, an \tcode{optional<U>} object
whose contained value is direct-non-list-initialized with
\tcode{invoke(std::forward<F>(f), *\exposid{val})};
otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\indexlibrarymember{transform}{optional}
\begin{itemdecl}
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be
\tcode{remove_cv_t<invoke_result_t<F, decltype(std::move(*\exposid{val}))>>}.

\pnum
\mandates
\begin{removedblock}
\tcode{U} is a non-array object type
other than \tcode{in_place_t} or \tcode{nullopt_t}.
\end{removedblock}
\begin{addedblock}
\tcode{U} is valid type for optional.
\end{addedblock}
The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), std::move(*@\exposid{val}@)));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

\pnum
\returns
If \tcode{*this} contains a value, an \tcode{optional<U>} object
whose contained value is direct-non-list-initialized with
\tcode{invoke(std::forward<F>(f), std::move(*\exposid{val}))};
otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\indexlibrarymember{or_else}{optional}
\begin{itemdecl}
template<class F> constexpr optional or_else(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{F} models \tcode{\libconcept{invocable}<>} and
\tcode{T} models \libconcept{copy_constructible}.

\pnum
\mandates
\tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return *this;
} else {
  return std::forward<F>(f)();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{or_else}{optional}
\begin{itemdecl}
template<class F> constexpr optional or_else(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{F} models \tcode{\libconcept{invocable}<>} and
\tcode{T} models \libconcept{move_constructible}.

\pnum
\mandates
\tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return std::move(*this);
} else {
  return std::forward<F>(f)();
}
\end{codeblock}
\end{itemdescr}

\rSec3[optional.mod]{Modifiers}

\begin{addedblock}
\rSec2[optional.optionalref]{Class template \tcode{optional} for reference types}

\rSec3[optional.optionalref.general]{General}
\begin{codeblock}
namespace std {
  template<class T>
  class optional<T&> {
    public:
      using value_type     = T;
      using iterator       = @\impdefnc@; // see~\ref{optionalref.iterators}

    public:
      // \ref{optionalref.ctor}, constructors
      constexpr optional() noexcept;
      constexpr optional(nullopt_t) noexcept;
      constexpr optional(const optional& rhs) noexcept = default;

      template <class Arg>
      constexpr explicit optional(in_place_t, Arg&& arg);

      template <class U> constexpr explicit(@\seebelow@) optional(U&& u) noexcept(@\seebelow@);

      template <class U> constexpr explicit(@\seebelow@) optional(optional<U>& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(const optional<U>& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(optional<U>&& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(const optional<U>&&& rhs) noexcept(@\seebelow@)

      constexpr ~optional() = default;

      // \ref{optionalref.assign}, assignment
      constexpr optional& operator=(nullopt_t) noexcept;
      constexpr optional& operator=(const optional& rhs) noexcept = default;

      template <class U> constexpr optional& emplace(U&& u) noexcept(@\seebelow@);

      // \ref{optionalref.swap}, swap
      constexpr void swap(optional& rhs) noexcept;

      // \ref{optional.iterators}, iterator support
      constexpr iterator begin() const noexcept;
      constexpr iterator end() const noexcept;

      // \ref{optionalref.observe}, observers
      constexpr T*       operator->() const noexcept;
      constexpr T&       operator*() const noexcept;
      constexpr explicit operator bool() const noexcept;
      constexpr bool     has_value() const noexcept;
      constexpr T&       value() const;                                // freestanding-deleted
      template <class U> constexpr remove_cv_t<T> value_or(U&& u) const;

      // \ref{optionalref.monadic}, monadic operations
      template <class F> constexpr auto and_then(F&& f) const;
      template <class F> constexpr auto transform(F&& f) const -> optional<invoke_result_t<F, T&>>;
      template <class F> constexpr optional or_else(F&& f) const;

      // \ref{optionalref.mod}, modifiers
      constexpr void reset() noexcept;

    private:
      T* val; // \expos
  };

}
\end{codeblock}

\pnum
An instance of optional<T\&> contains a value if \tcode{\exposid{val} != nullptr} is \tcode{true}.

\rSec3[optionalref.ctor]{Constructors}

\begin{itemdecl}
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to
\begin{codeblock}
@\exposid{val} = nullptr;
\end{codeblock}
\end{itemdescr}


\begin{itemdecl}
template <class Arg>
constexpr explicit optional(in_place_t, Arg&& arg);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, remove_cv_t<Arg>>} is \tcode{true}
  \item \tcode{detail::reference_constructs_from_temporary_v<T\&, Arg>)} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Initializes \exposid{val} with \tcode{addressof(static_cast<T\&>(std::forward<Arg>(arg)))}

\end{itemdescr}

\begin{itemdecl}
template <class U>
  constexpr explicit(@\seebelow@) optional(U&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}
  \item \tcode{(is_same_v<remove_cvref_t<U>, in_place_t>)} is \tcode{false}
  \item \tcode{(is_same_v<remove_cvref_t<U>, optional>)} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Initializes \tcode{\exposid{val}} with \tcode{addressof(static_cast<T\&>(std::forward<U>(u)))}.

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<U, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, U>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, U>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}



\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(optional<U>& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, U\&>} is \tcode{true}
  \item \tcode{std::is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}
  \item \tcode{std::is_same_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
if (rhs.has_value()) {
    @\exposid{val}@ = addressof(static_cast<T&>(rhs.value()));
} else {
    @\exposid{val}@ = nullptr;
}
  \end{codeblock}

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<U&, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, U&>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, U&>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}


\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(const optional<U>& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, const U\&>} is \tcode{true}
  \item \tcode{std::is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}
  \item \tcode{std::is_same_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
if (rhs.has_value()) {
    @\exposid{val}@ = addressof(static_cast<T&>(rhs.value()));
} else {
    @\exposid{val}@ = nullptr;
}
  \end{codeblock}


  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<const U&, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, const U&>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, const U&>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}


\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(optional<U>&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}
  \item \tcode{std::is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}
  \item \tcode{std::is_same_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
if (rhs.has_value()) {
    @\exposid{val}@ = addressof(static_cast<T&>(std::move(rhs).value()));
} else {
    @\exposid{val}@ = nullptr;
}
  \end{codeblock}

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<U, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, U>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, U>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(const optional<U>&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, const U>} is \tcode{true}
  \item \tcode{std::is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}
  \item \tcode{std::is_same_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
if (rhs.has_value()) {
    @\exposid{val}@ = addressof(static_cast<T&>(std::move(rhs).value()));
} else {
    @\exposid{val}@ = nullptr;
}
  \end{codeblock}

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<const U, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, const U>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, const U>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}


\rSec3[optionalref.assign]{Assignment}

\begin{itemdecl}
constexpr optional& operator=(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
@exposid{val} = nullptr;
  \end{codeblock}

  \pnum
  \returns
  \tcode{*this}.
\end{itemdescr}


\begin{itemdecl}
template <class U>
constexpr T& emplace(U&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
    \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}
    \item \tcode{reference_constructs_from_temporary_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Assigns \tcode{\exposid{val}} \tcode{addressof(static_cast<T\&>(std::forward<U>(u)))}

  \pnum
  \remarks
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, U>
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.swap]{Swap}

\begin{itemdecl}
constexpr void swap(optional& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
std::swap(@\exposid{val}@, rhs.@\exposid{val}@);
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.iterators]{Iterator support}
\begin{itemdecl}
using iterator = @\impdef@;
\end{itemdecl}

\begin{itemdescr}
\pnum
These types
model \libconcept{contiguous_iterator}\iref{iterator.concept.contiguous},
meet the \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}, and
meet the requirements for constexpr iterators\iref{iterator.requirements.general},
with value type \tcode{remove_cv_t<T>}.
The reference type is \tcode{T\&} for \tcode{iterator}.

\pnum
All requirements on container iterators\iref{container.reqmts} apply to
\tcode{optional::iterator}.

\end{itemdescr}


\begin{itemdecl}
constexpr iterator begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  If \tcode{has_value()} is \tcode{true},
  an iterator referring to the referred to value.
  Otherwise, a past-the-end iterator value.

\end{itemdescr}

\begin{itemdecl}
constexpr iterator end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{begin() + has_value()}.
\end{itemdescr}



\rSec3[optionalref.observe]{Observers}

\begin{itemdecl}
constexpr T* operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{\exposid{val}}.

\end{itemdescr}

\begin{itemdecl}
constexpr T& operator*() const noexcept;
\end{itemdecl}

\begin{itemdescr}
   \pnum
   \expects
   \tcode{has_value()} is \tcode{true}

   \pnum
   \returns
   \tcode{*\exposid{val}}.

\end{itemdescr}

\begin{itemdecl}
constexpr explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{\exposid{val} != nullptr}
\end{itemdescr}

\begin{itemdecl}
constexpr bool has_value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{\exposid{val} != nullptr}
\end{itemdescr}

\begin{itemdecl}
constexpr T& value() const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value()) {
  return *@\exposid{val}@;
}
throw bad_optional_access();
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr T value_or(U&& u) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \mandates
  \begin{itemize}
    \item \tcode{is_constructible_v<std::remove_cv_t<T>, T\&>} is \tcode{true}.
    \item \tcode{is_convertible_v<U, std::remove_cv_t<T>>} is \tcode{true}.
  \end{itemize}

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value()) {
    return remove_cv_t<T>(*@\exposid{val}@);
} else {
    return std::forward<U>(u);
}
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.monadic]{Monadic operations}

\begin{itemdecl}
template <class F>
constexpr auto and_then(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{U} be \tcode{invoke_result_t<F, T\&>}.

  \pnum
  \mandates
  \tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value()) {
    return invoke(std::forward<F>(f), *@\exposid{val}@);
} else {
    return remove_cvref_t<U>();
}
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class F>
constexpr auto transform(F&& f) const -> optional<invoke_result_t<F, T&>>;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, T\&>>}.

  \pnum
  \mandates
  \tcode{U} is a valid type for optional.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value()) {
    return optional<U>{invoke(std::forward<F>(f), *@\exposid{val}@)};
} else {
    return optional<U>{};
}
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class F>
constexpr optional or_else(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \mandates
  \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{true}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
    if (has_value()) {
        return *@\exposid{val}@;
    } else {
        return std::forward<F>(f)();
    }
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.mod]{Modifiers}

\begin{itemdecl}
constexpr void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
  @\exposid{val}@ = nullptr;
  \end{codeblock}
  \tcode{\exposid{val}} does not refer to a value.
\end{itemdescr}

\end{addedblock}

\rSec2[optional.nullopt]{No-value state indicator}
\rSec2[optional.bad.access]{Class \tcode{bad_optional_access}}
\rSec2[optional.relops]{Relational operators}
\rSec2[optional.specalg]{Specialized algorithms}
\indexlibrarymember{swap}{optional}%
\begin{itemdecl}
template<class T>
  constexpr void swap(optional<T>& x, optional<T>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{removedblock}
\constraints
\tcode{is_move_constructible_v<T>} is \tcode{true} and
\tcode{is_swappable_v<T>} is \tcode{true}.
\end{removedblock}

\begin{addedblock}
  \constraints
    \tcode{is_reference_v<T> || (is_move_constructible_v<T> \&\& is_swappable_v<T>)} is \tcode{true}.
\end{addedblock}

\pnum
\effects
Calls \tcode{x.swap(y)}.
\end{itemdescr}


\rSec2[optional.hash]{Hash support}
\indexlibrarymember{hash}{optional}%
\begin{itemdecl}
template<class T> struct hash<optional<T>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specialization \tcode{hash<optional<T>>} is enabled\iref{unord.hash}
if and only if \added{\tcode{is_reference_v<T>} is false and} \tcode{hash<remove_const_t<T>>} is enabled.
When enabled, for an object \tcode{o} of type \tcode{optional<T>},
if \tcode{o.has_value() == true}, then \tcode{hash<optional<T>>()(o)}
evaluates to the same value as \tcode{hash<remove_const_t<T>>()(*o)};
otherwise it evaluates to an unspecified value.
The member functions are not guaranteed to be \keyword{noexcept}.
\end{itemdescr}

\begin{addedblock}
\Sec2[version.syn]{Feature-test macro}
Add the following macro definition to [version.syn], header <version> synopsis, with the value selected by the editor to reflect the date of adoption of this paper:

\begin{codeblock}
  #define __cpp_lib_optional_ref 20XXXXL // also in <ranges>, <tuple>, <utility>
\end{codeblock}
\end{addedblock}
